<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">0</article-id>
<article-id pub-id-type="doi">N/A</article-id>
<title-group>
<article-title>tmech a C++ library for the numerical study of the
physics of continuous materials using higher-oder
tensors</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">0000-0001-8041-9538</contrib-id>
<name>
<surname>Lenz</surname>
<given-names>Peter</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="corresp" rid="cor-1"><sup>*</sup></xref>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Chair of Engineering Mechanics, Paderborn University,
Germany</institution>
</institution-wrap>
</aff>
</contrib-group>
<author-notes>
<corresp id="cor-1">* E-mail: <email></email></corresp>
</author-notes>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2022-05-01">
<day>1</day>
<month>5</month>
<year>2022</year>
</pub-date>
<volume>¿VOL?</volume>
<issue>¿ISSUE?</issue>
<fpage>¿PAGE?</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>c++</kwd>
<kwd>tensors</kwd>
<kwd>solid mechanics</kwd>
<kwd>tensor calculus</kwd>
<kwd>symbolic differentiation</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>The objective of the tmech framework is to propose high-level
  semantics, inspired by different linear algebra packages, allowing
  fast software prototyping in a low-level compiled language numerical
  study of the physics of continuous materials using higher-oder
  tensors.</p>
  <p>The tmech framework is provided as an open source software under
  the BSD-3-Clause License, compiled and validated with clang and
  gcc</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>For the numerical study of the physics of continuous materials
  using higher-oder tensors. Partial Differential Equations (PDEs)
  describing natural phenomena are modelled using tensors of different
  order. Two commonly studied problems are heat transfer, which include
  temperature and heat flux (rank-0 and rank-1 tensor, respectively),
  and continuum mechanics, which include stress and strain (rank-2
  tensors) and the so-called tangent stiffness (rank-4 tensor).</p>
</sec>
<sec id="overview-and-features">
  <title>Overview and features</title>
  <p>Non-indexed lower case light face Latin letters (e.g. f and h) are
  used for scalars</p>
  <sec id="tensor-operations-involving-overloaded-c-operator-functions">
    <title>Tensor operations involving overloaded C++ operator
    functions</title>
    <list list-type="bullet">
      <list-item>
        <p>Addition of tensors of same rank and dimension</p>
      </list-item>
      <list-item>
        <p>Subtraction of tensors of same rank and dimension</p>
      </list-item>
      <list-item>
        <p>Scalar update of tensors</p>
      </list-item>
    </list>
  </sec>
  <sec id="general-inner-product">
    <title>General inner product</title>
    <p>Hence if one of the original tensors is of rank-m and the other
    is of rank-n, the inner product will be of rank-(m + n − 2).
    Controlled by template parameters SeqLHS and SeqRHS. Bases contained
    in sequence SeqLHS are contracted with bases contained in sequence
    SeqLHS. tmech provides some wrapper functions for the most common
    inner products <inline-formula><alternatives>
    <tex-math><![CDATA[a:B]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[A:b]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>A</mml:mi><mml:mo>:</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[A:B]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>A</mml:mi><mml:mo>:</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[A::B]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>A</mml:mi><mml:mo>:</mml:mo><mml:mo>:</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
    see documentation for more details.</p>
    <code language="c++">using SeqL = tmech::sequence&lt;3,4&gt;;
using SeqR = tmech::sequence&lt;1,2&gt;;
//Double contraction of two 4th order tensors
tmech::tensor&lt;double, 3, 4&gt; A, B, C;
C = tmech::inner_product&lt;SeqL, SeqR&gt;(A,B);
//Double contraction of a 4th and a 2th order tensor
tmech::tensor&lt;double, 3, 2&gt; a, c;
c = tmech::inner_product&lt;SeqL, SeqR&gt;(C,a);</code>
  </sec>
  <sec id="general-outer-product">
    <title>General outer product</title>
    <p>On multiplying each component of a tensor of rank
    <inline-formula><alternatives>
    <tex-math><![CDATA[r]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>r</mml:mi></mml:math></alternatives></inline-formula>
    by each component of a tensor of rank <inline-formula><alternatives>
    <tex-math><![CDATA[k]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>k</mml:mi></mml:math></alternatives></inline-formula>,
    both of dimension <inline-formula><alternatives>
    <tex-math><![CDATA[m]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>m</mml:mi></mml:math></alternatives></inline-formula>,
    a tensor of rank <inline-formula><alternatives>
    <tex-math><![CDATA[(r + k)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    with mr+k components is obtained The outer product of a tensor of
    type (m, n) by a tensor of type (p, q) results in a tensor of type
    (m + p, n + q) the outer product of two tensors their outer product
    is a tensor. The outer product of tensors is also referred to as
    their tensor product, ontrolled by template parameters SeqLHS and
    SeqRHS. Bases contained in sequence SeqLHS are used for ordered
    element acces in A. Bases contained in SeqRHS are used for ordered
    element acces in B expression. tmech provides some wrapper functions
    for the most common outer products <inline-formula><alternatives>
    <tex-math><![CDATA[\otimes]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mo>⊗</mml:mo></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[\underline\otimes]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:munder><mml:mo>⊗</mml:mo><mml:mo accent="true">_</mml:mo></mml:munder></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[\underline\otimes]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:munder><mml:mo>⊗</mml:mo><mml:mo accent="true">_</mml:mo></mml:munder></mml:math></alternatives></inline-formula>,
    see documentation for more details. An example code snippet, where
    two second-order tensor are multiplied to form a fourth-oder tensor
    is given as</p>
    <code language="c++">using SeqL = tmech::sequence&lt;1,2&gt;;
using SeqR = tmech::sequence&lt;3,4&gt;;
...
tmech::tensor&lt;double, 3, 2&gt; a, b;
tmech::tensor&lt;double, 3, 4&gt; C;
C = tmech::outer_product&lt;SeqL, SeqR&gt;(a,b);</code>
    <p>where bases 1,2 of the new tensor C are given by a and bases 3,4
    are given by b.</p>
  </sec>
  <sec id="general-basis-rearrangement">
    <title>General basis rearrangement</title>
    <p>Controlled by template parameter Sequence, which contains the new
    order of bases. tmech provides some wrapper functions for the most
    common basis rearrangement like transposition of a second-order
    tensor and a major-transposition of a fourth-order tensor. An
    example code snippet</p>
    <code language="c++">//Basis 1,2,3,4 is swaped to 3,4,1,2.
tmech::tensor&lt;double, 3, 4&gt; A, B;
A.randn();
B = tmech::basis_change&lt;tmech::sequence&lt;3,4,1,2&gt;&gt;(A);
B = tmech::basis_change&lt;tmech::sequence&lt;3,4,1,2&gt;&gt;(A+2*A);</code>
  </sec>
  <sec id="decompositions">
    <title>Decompositions</title>
    <sec id="eigendecomposition">
      <title>Eigendecomposition</title>
      <p>Eigendecomposition of a positive semi-definite symmetric
      second-order tensor <disp-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{Y} = \sum_{i=1}^m \lambda_i \boldsymbol{e}_i \otimes \boldsymbol{e}_i = \sum_{i=1}^m \lambda_i \boldsymbol{E}_i,]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>𝐘</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>𝐞</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>𝐞</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>𝐄</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
      where <inline-formula><alternatives>
      <tex-math><![CDATA[m]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>m</mml:mi></mml:math></alternatives></inline-formula>
      is the number of non repeated eigenvalues,
      <inline-formula><alternatives>
      <tex-math><![CDATA[\lambda_i]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      are the corresponding eigenvalues, <inline-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{e}_i]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>𝐞</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      are eigenvectors and <inline-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{E}_i]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>𝐄</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      are eigenbasen.</p>
      <code language="c++">tmech::tensor&lt;double, 3, 2&gt; A, A_inv;
A = tmech::sym(tmech::randn&lt;double,3,2&gt;());
auto A_eig = tmech::eigen_decomposition(A);
const auto[eigenvalues, eigenbasis]{A_eig.decompose_eigenbasis()};
const auto idx{A_eig.non_repeated_eigenvalues_index()};
for(auto idx : A_eig.non_repeated_eigenvalues_index()){
    A_inv += (1.0/eigenvalues[idx])*eigenbasis[idx];
}
std::cout&lt;&lt;std::boolalpha&lt;&lt;tmech::almost_equal(tmech::inv(A), A_inv, 5e-7)&lt;&lt;std::endl;</code>
    </sec>
    <sec id="polar-decomposition">
      <title>Polar decomposition</title>
      <p>Polar decomposition of a positive semi-definite symmetric
      second-order tensor <disp-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{F}=\boldsymbol{R}\boldsymbol{U} = \boldsymbol{V}\boldsymbol{R}]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>𝐅</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold"><mml:mi>𝐔</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>𝐕</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></disp-formula>
      where <inline-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{R}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>
      is an orthogonal tensor also knwon as the rotation tensor,
      <inline-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{U}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>𝐔</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>
      and <inline-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{V}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>𝐕</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>
      are symmetric tensors called the right and the left stretch
      tensor, respectively. This function provides two different methods
      to determine <inline-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{U}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>𝐔</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>,
      <inline-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{V}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>𝐕</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>
      and <inline-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{R}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>.
      The first method uses spectral decomposition
      <disp-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{U} = \sqrt{\boldsymbol{F}^T\boldsymbol{F}}, \quad \boldsymbol{R} = \boldsymbol{F}\boldsymbol{U}^{-1},
      \quad \boldsymbol{V} = \boldsymbol{R}\boldsymbol{U}\boldsymbol{R}^T,]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>𝐔</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>𝐅</mml:mi></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:mstyle mathvariant="bold"><mml:mi>𝐅</mml:mi></mml:mstyle></mml:mrow></mml:msqrt><mml:mo>,</mml:mo><mml:mspace width="1.0em"></mml:mspace><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>𝐅</mml:mi></mml:mstyle><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>𝐔</mml:mi></mml:mstyle><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="1.0em"></mml:mspace><mml:mstyle mathvariant="bold"><mml:mi>𝐕</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold"><mml:mi>𝐔</mml:mi></mml:mstyle><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></p>
      <code language="c++">//use the spectral decomposition
tmech::tensor&lt;double, 3, 2&gt; F;
F.randn();
auto F_polar = tmech::polar_decomposition(F);
F = F_polar.R()*F_polar.U();
F = F_polar.V()*F_polar.R();</code>
      <p>The second one is based on a Newton iteration
      <disp-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{R}_{k+1} =\frac{1}{2} \left( \boldsymbol{R}_k + \boldsymbol{R}_k^{-T}\right), \quad \text{with}\quad \boldsymbol{R}_0 = \boldsymbol{F}]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle><mml:mi>k</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle><mml:mi>k</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mspace width="1.0em"></mml:mspace><mml:mtext mathvariant="normal">with</mml:mtext><mml:mspace width="1.0em"></mml:mspace><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>𝐅</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></disp-formula></p>
      <code language="c++">//use the newton iteration
tmech::tensor&lt;double, 3, 2&gt; F;
F.randn();
auto F_polar = tmech::polar_decomposition(F, // tensor to decompose
                                          true, //use newton iteration
                                          5e-7, // tolerance
                                          5 // number of max steps
                                          );
F = F_polar.R()*F_polar.U();
F = F_polar.V()*F_polar.R();</code>
      <p>The following derivatives are also important
      <disp-formula><alternatives>
      <tex-math><![CDATA[\frac{\partial \boldsymbol{U}}{\partial \boldsymbol{F}},
      \quad \frac{\partial \boldsymbol{V}}{\partial \boldsymbol{F}},
      \quad \frac{\partial \boldsymbol{R}}{\partial \boldsymbol{F}}]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>∂</mml:mi><mml:mstyle mathvariant="bold"><mml:mi>𝐔</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>∂</mml:mi><mml:mstyle mathvariant="bold"><mml:mi>𝐅</mml:mi></mml:mstyle></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mspace width="1.0em"></mml:mspace><mml:mfrac><mml:mrow><mml:mi>∂</mml:mi><mml:mstyle mathvariant="bold"><mml:mi>𝐕</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>∂</mml:mi><mml:mstyle mathvariant="bold"><mml:mi>𝐅</mml:mi></mml:mstyle></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mspace width="1.0em"></mml:mspace><mml:mfrac><mml:mrow><mml:mi>∂</mml:mi><mml:mstyle mathvariant="bold"><mml:mi>𝐑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>∂</mml:mi><mml:mstyle mathvariant="bold"><mml:mi>𝐅</mml:mi></mml:mstyle></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></disp-formula>
      explicit results are given here</p>
      <code language="c++">//use the spectral decomposition
tmech::tensor&lt;double, 3, 2&gt; F;
F.randn();
auto F_polar = tmech::polar_decomposition(F);
auto dR = F_polar.R().derivative();
auto dU = F_polar.U().derivative();
auto dV = F_polar.V().derivative();</code>
    </sec>
  </sec>
  <sec id="nummerical-differentiation">
    <title>Nummerical differentiation</title>
    <p>Numerical differentiation based on central difference scheme
    <inline-formula><alternatives>
    <tex-math><![CDATA[f'(x) \approx \frac{f(x+h) - f(x-h)}{2h}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mi>′</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:mfrac><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula></p>
    <sec id="non-symmetric-tensor-functions">
      <title>Non-symmetric tensor functions</title>
      <code language="c++">tmech::tensor&lt;double,3,2&gt; X;
X.randn();
auto func = [&amp;](auto const&amp; F){return 1.5*(tmech::trace(tmech::trans(F)*F) - 3); };
auto dFunc = tmech::num_diff_central(func, X);
auto dFunc_ = [&amp;](auto const&amp; F){return tmech::num_diff_central(func, F);};
auto ddFunc = tmech::num_diff_central&lt;tmech::sequence&lt;1,2,3,4&gt;&gt;(func, X);</code>
    </sec>
    <sec id="symmetric-tensor-functions">
      <title>Symmetric tensor functions</title>
      <code language="c++">using Sym2x2 = std::tuple&lt;tmech::sequence&lt;1,2&gt;,tmech::sequence&lt;2,1&gt;&gt;;
//symmetry of the result
using Sym4x4 = std::tuple&lt;
               tmech::sequence&lt;1,2,3,4&gt;,
               tmech::sequence&lt;2,1,3,4&gt;,
               tmech::sequence&lt;1,2,4,3&gt;,
               tmech::sequence&lt;2,1,4,3&gt;&gt;;
tmech::tensor&lt;double,3,2&gt; X;
X = tmech::sym(tmech::rand&lt;double,3,2&gt;());
//first deriv
auto func = [&amp;](auto const&amp; F){return 1.5*(tmech::trace(tmech::trans(F)*F) - 3);};
auto dfunc_res = tmech::num_diff_sym_central&lt;Sym2x2&gt;(func, X);
//second deriv
auto dfunc = [&amp;](auto const&amp; F){return tmech::num_diff_sym_central&lt;Sym2x2&gt;(func, F);};
auto ddfunc_res = tmech::num_diff_sym_central&lt;Sym2x2, Sym4x4&gt;(dfunc, X);</code>
    </sec>
  </sec>
</sec>
<sec id="compile-time-differentiation">
  <title>Compile-time differentiation</title>
  <p>As an illustrative example of using tmech, we here give the
  mathematical formulation of an energy potential and stress in large
  deformation continuum mechanics and its implementation as a function
  in Julia. For a deformation gradient F = I + grad u, where u is the
  displacement from the reference to the current configuration, the
  right Cauchy-Green deformation tensor is defined by C=FTF. The Second
  Piola-Kirchoff stress tensor S is derived from the Helmholtz free
  energy psi by the relation
  <named-content id="eqU003AMooneyRivlin" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\label{eq:MooneyRivlin}
  \boldsymbol{S} = 2\frac{\partial \psi}{\partial \boldsymbol{C}}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>𝐒</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mfrac><mml:mrow><mml:mi>∂</mml:mi><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>∂</mml:mi><mml:mstyle mathvariant="bold"><mml:mi>𝐂</mml:mi></mml:mstyle></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></disp-formula></named-content></p>
  <p>The strain energy density function for an incompressible
  Mooney–Rivlin material is
  <named-content id="eqU003AMooneyRivlin" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\label{eq:MooneyRivlin}
  \psi = C_{10}(I_1 - 3) + C_{01}(I_2 - 3),\quad \text{where}\quad I_1 = \text{trace} \boldsymbol{C},\quad I_2 = \frac{1}{2}(I_1^2 - \text{trace}(\boldsymbol{C}^2))]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ψ</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mn>10</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mn>01</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mspace width="1.0em"></mml:mspace><mml:mtext mathvariant="normal">where</mml:mtext><mml:mspace width="1.0em"></mml:mspace><mml:msub><mml:mi>I</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mtext mathvariant="normal">trace</mml:mtext><mml:mstyle mathvariant="bold"><mml:mi>𝐂</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:mspace width="1.0em"></mml:mspace><mml:msub><mml:mi>I</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>I</mml:mi><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:mtext mathvariant="normal">trace</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>𝐂</mml:mi></mml:mstyle><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></named-content>
  where is the isochoric part</p>
  <code language="c++"></code>
</sec>
<sec id="user-material-in-abaqus">
  <title>User material in Abaqus</title>
  <p>Abaqus is a commerical software and often used in research
  (<xref alt="Abaqus, 2014" rid="ref-Abaqus" ref-type="bibr">Abaqus,
  2014</xref>)</p>
  <fig>
    <caption><p>Caption for example
    figure.<styled-content id="figU003Aexample"></styled-content></p></caption>
    <graphic mimetype="application" mime-subtype="pdf" xlink:href="TensileSpecimen.pdf" xlink:title="" />
  </fig>
  <p><inline-graphic id="sealB" mimetype="application" mime-subtype="pdf" xlink:href="TensileSpecimen.pdf" />
  <inline-graphic id="sealC" mimetype="application" mime-subtype="pdf" xlink:href="TensileSpecimen.pdf" /></p>
  <p>Caption: Look at all my baby seals!</p>
  <boxed-text id="figU003Afig1">
    <p><inline-graphic id="sealB" mimetype="application" mime-subtype="pdf" xlink:href="TensileSpecimen.pdf" />
    <inline-graphic id="sealC" mimetype="application" mime-subtype="pdf" xlink:href="TensileSpecimen.pdf" /></p>
    <p>Look at my tiny horses!</p>
  </boxed-text>
  <p></p>
  <code language="c++">#include &lt;tmech/tmech.h&gt;
using tensor2 = tmech::tensor&lt;double,3,2&gt;;
using tensor4 = tmech::tensor&lt;double,3,4&gt;;

extern &quot;C&quot; void umat_(double *stress, double *statev, double *ddsdde, double *sse,
        double *spd, double *scd, double *rpl, double *ddsddt, double *drplde,
        double *drpldt, double *stran, double *dstran, double *time, double *dtime, 
        double *temp, double *dtemp, double *predef, double *dpred, char *cmname,
        int *ndi, int *nshr, int *ntens, int *nstatv, double *props, int *nprops, 
        double *coords, double *drot, double *pnewdt, double *celent, double *dfgrd0, 
        double *dfgrd1, int *noel, int *npt, int *layer, int *kspt, 
        int *kstep, int *kinc, short cmname_len){
    //parameters
    const double E     = props[0]; //210000
    const double nue   = props[1]; //0.3
    
    //Lamé parameters
    const double mu     = E/(2*(1+nue)); 
    const double lambda = E*nue/((1+nue)*(1-2*nue));
    
    
    //second order tensor
    const tmech::eye&lt;double,3,2&gt; I;
    //fourth order symmetric identity tensor 
    const auto IIsym = 0.5*(tmech::otimesu(I,I) + tmech::otimesl(I,I));
    //fourth order identity tensor
    const auto II = tmech::otimes(I,I);
    
    //voigt to tensor currently abq_std only Dim==3 supported
    tmech::adaptor&lt;double,3,2, tmech::abq_std&lt;3,true&gt;&gt; strain(stran);
    tmech::adaptor&lt;double,3,2, tmech::abq_std&lt;3,true&gt;&gt; dstrain(dstran);
    tmech::adaptor&lt;double,3,2, tmech::abq_std&lt;3&gt;&gt; sig(stress);
    tmech::adaptor&lt;double,3,4, tmech::abq_std&lt;3&gt;&gt; C(ddsdde);
    
    //updated strain
    const tensor2 eps = strain + dstrain;
    //trail stress 
    const tensor2 sig_tr = lambda*tmech::trace(eps)*I + 2*mu*(eps);
    //elasticity tensor
    C = lambda*II + 2*mu*IIsym;
}</code>
  <p>: Abaqus example linear elasticity.</p>
  <p>Compile to obtaine the . With the following commands for a Linux
  based operating system the object file is generated</p>
  <code language="bash">gcc -c -fPIC -O3 -march=native -std=c++17 -I/path_to_tmech -o  object_file_output.o input_name.cpp</code>
  <p>The compile flags -03 and -march=native are used to enable
  optimization and auto vectorization of the code, respectively. After
  the object file is generated, a Abaqus job can be submitted by the
  following commands</p>
  <code language="bash">abaqus job=input_file_name user=object_file_output</code>
  <p>where input_file_name is the name of the .inp input file and
  object_file_output is the name of the generated object file.</p>
  <p>A more complex example of J2-plasticity is given in the ‘tmech’
  github repositories</p>
</sec>
</body>
<back>
<ref-list>
  <ref id="ref-Abaqus">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Abaqus</surname></name>
      </person-group>
      <source>Abaqus/standard user’s manual, version 6.14</source>
      <publisher-name>Dassault Systèmes Simulia Corporation</publisher-name>
      <publisher-loc>Providence, RI, USA</publisher-loc>
      <year iso-8601-date="2014">2014</year>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
